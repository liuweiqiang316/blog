const e=JSON.parse('{"key":"v-f77099ba","path":"/posts/run.html","title":"生成器自动执行函数","lang":"zh-CN","frontmatter":{"description":"生成器自动执行函数 调用生成器函数会生成一个迭代器（iterator）。 对迭代器进行遍历就是一个生成器的执行函数（run0），这个函数是同步执行的只能用来处理gen这种简单的生成器函数。run0这里用到while循环遍历，其实用for循环应该也是一样的。 run1、run2用的都是内部函数递归调用。不同点在于，run1用的是回调函数的形式，run2用的是Promise的形式，所以其实run1递归调用step时同步代码不会等异步函数执行，run2递归调用的step是包裹在Promise.then函数的内部执行函数中，所以run2一定是等到gen1内部的异步代码执行完成后才会执行下一次step也就是说一定会等到gen1函数内部yield的结果后才开始执行下面的代码。","head":[["meta",{"property":"og:url","content":"http://liuweiqiang316.cn/blog/posts/run.html"}],["meta",{"property":"og:title","content":"生成器自动执行函数"}],["meta",{"property":"og:description","content":"生成器自动执行函数 调用生成器函数会生成一个迭代器（iterator）。 对迭代器进行遍历就是一个生成器的执行函数（run0），这个函数是同步执行的只能用来处理gen这种简单的生成器函数。run0这里用到while循环遍历，其实用for循环应该也是一样的。 run1、run2用的都是内部函数递归调用。不同点在于，run1用的是回调函数的形式，run2用的是Promise的形式，所以其实run1递归调用step时同步代码不会等异步函数执行，run2递归调用的step是包裹在Promise.then函数的内部执行函数中，所以run2一定是等到gen1内部的异步代码执行完成后才会执行下一次step也就是说一定会等到gen1函数内部yield的结果后才开始执行下面的代码。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-22T16:47:24.000Z"}],["meta",{"property":"article:author","content":"微斯人"}],["meta",{"property":"article:modified_time","content":"2023-04-22T16:47:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"生成器自动执行函数\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-04-22T16:47:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"微斯人\\",\\"url\\":\\"http://liuweiqiang316.cn/\\"}]}"]]},"headers":[],"git":{"createdTime":1682182044000,"updatedTime":1682182044000,"contributors":[{"name":"liuweiqiang","email":"liuweiqiang316@163.com","commits":1}]},"readingTime":{"minutes":1.58,"words":473},"filePathRelative":"posts/run.md","localizedDate":"2023年4月22日","excerpt":"<h1> 生成器自动执行函数</h1>\\n<p>调用生成器函数会生成一个迭代器（<code>iterator</code>）。</p>\\n<p>对迭代器进行遍历就是一个生成器的执行函数（<code>run0</code>），这个函数是同步执行的只能用来处理<code>gen</code>这种简单的生成器函数。<code>run0</code>这里用到<code>while</code>循环遍历，其实用<code>for</code>循环应该也是一样的。</p>\\n<p><code>run1、run2</code>用的都是内部函数递归调用。不同点在于，<code>run1</code>用的是回调函数的形式，<code>run2</code>用的是<code>Promise</code>的形式，所以其实<code>run1</code>递归调用<code>step</code>时同步代码不会等异步函数执行，<code>run2</code>递归调用的<code>step</code>是包裹在Promise.then函数的内部执行函数中，所以<code>run2</code>一定是等到<code>gen1</code>内部的异步代码执行完成后才会执行下一次<code>step</code>也就是说一定会等到<code>gen1</code>函数内部<code>yield</code>的结果后才开始执行下面的代码。</p>","autoDesc":true}');export{e as data};
